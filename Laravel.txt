8/13
I studied about Routing in Laravel
basic routes: Route:get('foo', function(){return "success!";})

multiple router:
Route::match(['get', 'post'], '/', function () {
    //
});

Route::any('/', function () {
    //
});

CSRF protection: 
<form method="POST" action="/profile">
    @csrf
    ...
</form>
if you don't use @csrf, it will be rejected

Redirect Route: Route::redirect('/here', '/there');

When you need only view, you can use view: Route::view('/welcome', 'welcome');

Also you can send parameter: Route::get('user/{id}', function ($id) {
    return 'User '.$id;
});

you can make format of parameters using where method:
Route::get('user/{name}', function ($name) {
    //
})->where('name', '[A-Za-z]+');

You can make global format to add pattern
public function boot()
{
    Route::pattern('id', '[0-9]+');

    parent::boot();
}

Route Prefixes:
Route::prefix('admin')->group(function () {
    Route::get('users', function () {
        // Matches The "/admin/users" URL
    });
});

Route Limiting:
60times join for 1 min
Route::middleware('auth:api', 'throttle:60,1')->group(function () {
    Route::get('/user', function () {
        //
    });
});

8/17
Middleware
Middleware provide a convenient mechanism for filtering HTTP requests entering your application.
Creating Middleware 
php artisan make:middleware CheckAge
You can create middleware using above command.
All Middlewares will place in App/HTTP/Middleware.
This is middleware example:
<?php

namespace App\Http\Middleware;

use Closure;

class CheckAge
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if ($request->age <= 200) {
            return redirect('home');
        }

        return $next($request);
    }
}

global middleware will be place in the $middleware property of your app/Http/Kernal.php class.
Assigning Middleware To Routes:
Route::get('admin/profile', function () {
    //
})->middleware('auth');
You may also assign multiple middleware to the route:

Route::get('/', function () {
    //
})->middleware('first', 'second');
We can use $middlewarePriority property of your app/Http/Kernel.php file for sort middleware order
Middleware parameters may be specified when defining the route by separating the middleware name and parameters with a :. Multiple parameters should be delimited by commas:

Route::put('post/{id}', function ($id) {
    //
})->middleware('role:editor');

8/18
CSRF Protection
CSRF is  Cross-site request forgeries. This is a type or malicious exploit whereby unuthorized commands
are performed on behalf of an authenticated user.
Anytime you define an HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field:
example: <form method="POST" action="/profile">
    @csrf
    ...
</form>
If you use axios HTTP library, this token generate automatically, but if not, you should add manually
If you want to except some uri from CSRF protection, you can user $except property of the VerifyCsrfToken middleware
example:
protected $except = [
        'stripe/*',
        'http://example.com/foo/bar',
        'http://example.com/foo/*',
    ];
X-CSRF-TOKEN
<meta name="csrf-token" content="{{ csrf_token() }}">
$.ajaxSetup({
    headers: {
        'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    }
});
There is X-XSRF-TOKEN too..

Controllers
Instead of defining all of your request handling logic as Closures in route files, you may wish to organize this behavior using Controller classes.
Controllers are stored in the app/Http/Controllers directory.
Basic Controllers
-Defining Controllers
-Controllers & Namespaces
-Single Action Controllers
Controller Middleware
Resource Controllers
-Partial Resource Routes
-Nested Resources
-Naming Resource Routes
-Naming Resource Route Parameters
-Scoping Resource Routes
-Localizing Resource URIs
-Supplementing Resource Controllers
Dependency Injection & Controllers
Route Caching
You can define a route to this controller action like so:
Route::get('user/{id}', 'UserController@show');
Namespaces: Route::get('foo', 'Photos\AdminController@method');
If you would like to define a controller that only handles a single action, you may place a single __invoke method on the controller:
example: public function __invoke($id)
    {
        return view('user.profile', ['user' => User::findOrFail($id)]);
    }
When registering routes for single action controllers, you do not need to specify a method:

Route::get('user/{id}', 'ShowProfile');
making invokable controller command: php artisan make:controller ShowProfile --invokable
Controller Middleware
Middleware may be assigned to the controller's routes in your route files:
Route::get('profile', 'UserController@show')->middleware('auth');
Using the make:controller Artisan command, we can quickly create such a controller:
php artisan make:controller PhotoController --resource
You may register many resource controllers at once by passing an array to the resources method:
Route::resources([
    'photos' => 'PhotoController',
    'posts' => 'PostController',
]);
php artisan make:controller PhotoController --resource --model=Photo
<form action="/foo/bar" method="POST">
    @method('PUT')
</form>
Naming Resource Route: Route::resource('photos', 'PhotoController')->names([
    'create' => 'photos.build'
]);
Route Caching
If you active route caching, router register speed will be 100X faster
generate cache: php artisan route:cache
remove cache: php artisan route:clear

8/18
Requests
Accessing The Request
-Request Path & Method
-PSR-7 Requests
Input Trimming & Normalization
Retrieving Input
-Old Input
-Cookies
Files
-Retrieving Uploaded Files
-Storing Uploaded Files

Retrieving The Request Path
The path method returns the request's path information. So, if the incoming request is targeted at http://domain.com/foo/bar, the path method will return foo/bar:
$uri = $request->path();

To retrieve the full URL for the incoming request you may use the url or fullUrl methods. The url method will return the URL without the query string, while the fullUrl method includes the query string:
$url = $request->url();
$url = $request->fullUrl();
Retrieving An Input Value
Using a few simple methods, you may access all of the user input from your Illuminate\Http\Request instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the input method may be used to retrieve user input:
$name = $request->input('name');
Multivalue is possible
Retrieving Input From The Query String
While the input method retrieves values from entire request payload (including the query string), the query method will only retrieve values from the query string:
$name = $request->query('name');
Multivalue is possible
Retrieving Input Via Dynamic Properties
$name = $request->name;
Retrieving JSON Input Values
$name = $request->input('user.name');
Retrieving Boolean Input Values
$archived = $request->boolean('archived');
Determining If An Input Value Is Present
if ($request->has('name')) {
    //
}
if ($request->filled('name')) {
    //
}
if ($request->missing('name')) {
    //
}
Retrieving Old Input
To retrieve flashed input from the previous request, use the old method on the Request instance. The old method will pull the previously flashed input data from the session:
$username = $request->old('username');
Attaching Cookies To Responses
return response('Hello World')->cookie(
    'name', 'value', $minutes
);
File Paths & Extensions
$path = $request->photo->path();
$extension = $request->photo->extension();
File storing
$path = $request->photo->store('images');
$path = $request->photo->store('images', 's3');
Configuring Trusted Proxies
protected $proxies = [
        '192.168.1.1',
        '192.168.1.2',
    ];
For all proxies, we can use '*'

8/20
HTTP Responses

Creating Responses
-Attaching Headers To Responses
-Attaching Cookies To Responses
-Cookies & Encryption
Redirects
-Redirecting To Named Routes
-Redirecting To Controller Actions
-Redirecting To External Domains
-Redirecting With Flashed Session Data
Other Response Types
-View Responses
-JSON Responses
-File Downloads
-File Responses
Response Macros

Creating Response
Route::get('/', function () {
    return 'Hello World';
});
response can be string and array, object.
Attach header and cookies to response
return response($content)
                ->header('Content-Type', $type)
                ->cookie('name', 'value', $minutes);
Redirect
Route::get('dashboard', function () {
    return redirect('home/dashboard');
});
Redirecting To Named Routes
return redirect()->route('login');
Redirecting To Controller Actions
return redirect()->action('HomeController@index');
Redirecting To External Domains
return redirect()->away('https://www.google.com');
View Responses
return response()
            ->view('hello', $data, 200)
            ->header('Content-Type', $type);
JSON Responses
return response()->json([
    'name' => 'Abigail',
    'state' => 'CA',
]);
File Downloads
return response()->download($pathToFile);
return response()->download($pathToFile, $name, $headers);
return response()->download($pathToFile)->deleteFileAfterSend();

Streamed Downloads
return response()->streamDownload(function () {
    echo GitHub::api('repo')
                ->contents()
                ->readme('laravel', 'laravel')['contents'];
}, 'laravel-readme.md');
File Responses
return response()->file($pathToFile);
return response()->file($pathToFile, $headers);
Response Macros
If you would like to define a custom response that you can re-use in a variety of your routes and controllers, you may use the macro method on the Response facade. For example, from a service provider's boot method:

8/21
Views
Creating Views
Passing Data To Views
-Sharing Data With All Views
View Composers
Optimizing Views

Views are stored in the resources/views directory.
<html>
    <body>
        <h1>Hello, {{ $name }}</h1>
    </body>
</html>
Route::get('/', function () {
    return view('greeting', ['name' => 'James']);
});
"Dot" notation may be used to reference nested views. For example, if your view is stored at resources/views/admin/profile.blade.php, you may reference it like so:
return view('admin.profile', $data);
If you need to determine if a view exists, you may use the View facade. The exists method will return true if the view exists:
use Illuminate\Support\Facades\View;
if (View::exists('emails.customer')) {
    //
}
Passing Data To Views
return view('greetings', ['name' => 'Victoria']);
return view('greeting')->with('name', 'Victoria');
Sharing Data With All Views
public function boot()
    {
        View::share('key', 'value');
    }
View Composers
public function boot()
    {
        // Using class based composers...
        View::composer(
            'profile', 'App\Http\View\Composers\ProfileComposer'
        );

        // Using Closure based composers...
        View::composer('dashboard', function ($view) {
            //
        });
    }
Attaching A Composer To Multiple Views
View::composer(
    ['profile', 'dashboard'],
    'App\Http\View\Composers\MyViewComposer'
);
View::composer('*', function ($view) {
    //
});
View Createors
View::creator('profile', 'App\Http\View\Creators\ProfileCreator');
Optimizing Views
Compiling views during the request negatively impacts performance, so Laravel provides the view:cache Artisan command to precompile all of the views utilized by your application
php artisan view:cache
You may use the view:clear command to clear the view cache:
php artisan view:clear

8/23
URL Generation
Introduction
The Basics
-Generating Basic URLs
-Accessing The Current URL
URLs For Named Routes
-Signed URLs

URLs For Controller Actions
Default Values
The url helper may be used to generate arbitrary URLs for your application.
$post = App\Post::find(1);
echo url("/posts/{$post->id}");

Accessing The Current URL
echo url()->current();
echo url()->full();
echo url()->previous();
echo URL::current();

URLs For Named Routes
Route::get('/post/{post}', function () {
    //
})->name('post.show');
echo route('post.show', ['post' => 1]);
echo route('post.show', ['post' => $post]);
Route::get('/post/{post}/comment/{comment}', function () {
    //
})->name('comment.show');
echo route('comment.show', ['post' => 1, 'comment' => 3]);

Signed URLs
use Illuminate\Support\Facades\URL;
return URL::signedRoute('unsubscribe', ['user' => 1]);
use Illuminate\Support\Facades\URL;
return URL::temporarySignedRoute(
    'unsubscribe', now()->addMinutes(30), ['user' => 1]
);
-Validating Signed Route Requests
use Illuminate\Http\Request;
Route::get('/unsubscribe/{user}', function (Request $request) {
    if (! $request->hasValidSignature()) {
        abort(401);
    }
    // ...
})->name('unsubscribe');
protected $routeMiddleware = [
    'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
];
Route::post('/unsubscribe/{user}', function (Request $request) {
    // ...
})->name('unsubscribe')->middleware('signed');

URLs For Controller Actions
$url = action('HomeController@index');
use App\Http\Controllers\HomeController;
$url = action([HomeController::class, 'index']);
$url = action('UserController@profile', ['id' => 1]);

Default Values
Route::get('/{locale}/posts', function () {
    //
})->name('post.index');
It is cumbersome to always pass the locale every time you call the route helper. So, you may use the URL::defaults method to define a default value for this parameter that will always be applied during the current request. You may wish to call this method from a route middleware so that you have access to the current request:
<?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Support\Facades\URL;

class SetDefaultLocaleForUrls
{
    public function handle($request, Closure $next)
    {
        URL::defaults(['locale' => $request->user()->locale]);

        return $next($request);
    }
}

8/24
HTTP Session
Introduction
-Configuration
-Driver Prerequisites
Using The Session
-Retrieving Data
-Storing Data
-Flash Data
-Deleting Data
-Regenerating The Session ID
Session Blocking
Adding Custom Session Drivers
-Implementing The Driver
-Registering The Driver

8/25
8/27
file - sessions are stored in storage/framework/sessions.
cookie - sessions are stored in secure, encrypted cookies.
database - sessions are stored in a relational database.
memcached / redis - sessions are stored in one of these fast, cache based stores.
array - sessions are stored in a PHP array and will not be persisted.

Database
Schema::create('sessions', function ($table) {
    $table->string('id')->unique();
    $table->foreignId('user_id')->nullable();
    $table->string('ip_address', 45)->nullable();
    $table->text('user_agent')->nullable();
    $table->text('payload');
    $table->integer('last_activity');
});

Redis
Before using Redis sessions with Laravel, you will need to either install the PhpRedis PHP extension via PECL or install the predis/predis package (~1.0) via Composer.

Retrieving Data
$value = $request->session()->get('key');
$value = $request->session()->get('key', 'default');
$value = $request->session()->get('key', function () {
    return 'default';
});
The Global Session Helper
 $value = session('key');
 $value = session('key', 'default');
 session(['key' => 'value']);
Retrieving All Session Data
$data = $request->session()->all();
Determining If An Item Exists In The Session
if ($request->session()->has('users')) {
    //
}
Storing Data
$request->session()->put('key', 'value');
session(['key' => 'value']);
Pushing To Array Session Values
$request->session()->push('user.teams', 'developers');
Retrieving & Deleting An Item
$value = $request->session()->pull('key', 'default')
Flash Data
$request->session()->flash('status', 'Task was successful!');
Deleting Data
$request->session()->forget('key');
$request->session()->forget(['key1', 'key2']);
$request->session()->flush();
Regenerating The Session ID
$request->session()->regenerate();
Session Blocking
Route::post('/profile', function () {
})->block($lockSeconds = 10, $waitSeconds = 10)
Route::post('/order', function () {
})->block($lockSeconds = 10, $waitSeconds = 10)
Implementing The Driver
class MongoSessionHandler implements \SessionHandlerInterface
{
    public function open($savePath, $sessionName) {}
    public function close() {}
    public function read($sessionId) {}
    public function write($sessionId, $data) {}
    public function destroy($sessionId) {}
    public function gc($lifetime) {}
}
Registering The Driver
 Session::extend('mongo', function ($app) {
            // Return implementation of SessionHandlerInterface...
            return new MongoSessionHandler;
        });
8/30, 8/31
Validation

Introduction
Validation Quickstart
-Defining The Routes
-Creating The Controller
-Writing The Validation Logic
-Displaying The Validation Errors
-A Note On Optional Fields
Form Request Validation
-Creating Form Requests
-Authorizing Form Requests
-Customizing The Error Messages
-Customizing The Validation Attributes
-Prepare Input For Validation
Manually Creating Validators
-Automatic Redirection
-Named Error Bags
-After Validation Hook
Working With Error Messages
-Custom Error Messages
Available Validation Rules
Conditionally Adding Rules
Validating Arrays
Custom Validation Rules
-Using Rule Objects
-Using Closures
-Using Extensions
-Implicit Extensions
Laravel provides several different approaches to validate your application's incoming data. By default, Laravel's base controller class uses a ValidatesRequests trait which provides a convenient method to validate incoming HTTP requests with a variety of powerful validation rules.
Defining The Routes
First, let's assume we have the following routes defined in our routes/web.php file:
Route::get('post/create', 'PostController@create');
Route::post('post', 'PostController@store');
Writing The Validation Logic
public function store(Request $request)
{
    $validatedData = $request->validate([
        'title' => 'required|unique:posts|max:255',
        'body' => 'required',
    ]);
}
A Note On Nested Attributes
$request->validate([
    'title' => 'required|unique:posts|max:255',
    'author.name' => 'required',
    'author.description' => 'required',
]);
Customizing The Validation Attributes
public function attributes()
{
    return [
        'email' => 'email address',
    ];
}
Prepare Input For Validation
protected function prepareForValidation()
{
    $this->merge([
        'slug' => Str::slug($this->slug),
    ]);
}
Manually Creating Validators
 public function store(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ]);

        if ($validator->fails()) {
            return redirect('post/create')
                        ->withErrors($validator)
                        ->withInput();
        }
    }
Automatic Redirection
Validator::make($request->all(), [
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
])->validate();
Validator::make($request->all(), [
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
])->validateWithBag('post');

Error Handling
Introduction
Configuration
The Exception Handler
-Report Method
-Render Method
-Reportable & Renderable Exceptions
HTTP Exceptions
-Custom HTTP Error Pages

Introduction
The App\Exceptions\Handler class is where all exceptions triggered by your application are logged and then rendered back to the user.

Configuration
If you set the APP_DEBUG environment variable to true, you can enable debug option.

The Exception Handler
-The Report Method
  if ($exception instanceof CustomException) {
        //
    }
    parent::report($exception);
 1.Global Log Context
 2.The report Helper
 3.Ignoring Exceptions By Type
-The Render Method
public function render($request, Throwable $exception)
{
    if ($exception instanceof CustomException) {
        return response()->view('errors.custom', [], 500);
    }

    return parent::render($request, $exception);
}
-Reportable & Renderable Exceptions
HTTP Exceptions
In order to generate such a response from anywhere in your application, you may use the abort helper:
abort(403, 'Unauthorized action.');
-Custom HTTP Error Pages
If you wish to customize the error page for 404 HTTP status codes, create a resources/views/errors/404.blade.php. 
<h2>{{ $exception->getMessage() }}</h2>
You may publish Laravel's error page templates using the vendor:publish Artisan command. Once the templates have been published, you may customize them to your liking:

php artisan vendor:publish --tag=laravel-errors

9/2
Logging
Introduction
Configuration
-Building Log Stacks
Writing Log Messages
-Writing To Specific Channels
Advanced Monolog Channel Customization
-Customizing Monolog For Channels
-Creating Monolog Handler Channels
-Creating Channels Via Factories

Introduction
To help you learn more about what's happening within your application, Laravel provides robust logging services that allow you to log messages to files, the system error log, and even to Slack to notify your entire team.
Monolog library

Configuration
All of the configuration for your application's logging system is housed in the config/logging.php configuration file. 

Configuring The Channel Name
'stack' => [
    'driver' => 'stack',
    'name' => 'channel-name',
    'channels' => ['single', 'slack'],
],

Writing Log Messages
Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);
Creating Monolog Handler Channels
'logentries' => [
    'driver'  => 'monolog',
    'handler' => Monolog\Handler\SyslogUdpHandler::class,
    'with' => [
        'host' => 'my.logentries.internal.datahubhost.company.com',
        'port' => '10000',
    ],
],
Monolog Formatters
'browser' => [
    'driver' => 'monolog',
    'handler' => Monolog\Handler\BrowserConsoleHandler::class,
    'formatter' => Monolog\Formatter\HtmlFormatter::class,
    'formatter_with' => [
        'dateFormat' => 'Y-m-d',
    ],
],
'newrelic' => [
    'driver' => 'monolog',
    'handler' => Monolog\Handler\NewRelicHandler::class,
    'formatter' => 'default',
],
Creating Channels Via Factories
'channels' => [
    'custom' => [
        'driver' => 'custom',
        'via' => App\Logging\CreateCustomLogger::class,
    ],
],
Once you have configured the custom channel, you're ready to define the class that will create your Monolog instance. This class only needs a single method: __invoke, which should return the Monolog instance:
class CreateCustomLogger
{
    public function __invoke(array $config)
    {
        return new Logger(...);
    }
}
9/3, 9/4
Blade Templates

Introduction
Template Inheritance
-Defining A Layout
-Extending A Layout
Displaying Data
-Blade & JavaScript Frameworks
Control Structures
-If Statements
-Switch Statements
-Loops
-The Loop Variable
-Comments
-PHP
-The @once Directive
Forms
-CSRF Field
-Method Field
-Validation Errors
Components
-Displaying Components
-Passing Data To Components
-Managing Attributes
-Slots
-Inline Component Views
-Anonymous Components
Including Subviews
-Rendering Views For Collections
Stacks
Service Injection
Extending Blade
-Custom If Statements
