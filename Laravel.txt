8/13
I studied about Routing in Laravel
basic routes: Route:get('foo', function(){return "success!";})

multiple router:
Route::match(['get', 'post'], '/', function () {
    //
});

Route::any('/', function () {
    //
});

CSRF protection: 
<form method="POST" action="/profile">
    @csrf
    ...
</form>
if you don't use @csrf, it will be rejected

Redirect Route: Route::redirect('/here', '/there');

When you need only view, you can use view: Route::view('/welcome', 'welcome');

Also you can send parameter: Route::get('user/{id}', function ($id) {
    return 'User '.$id;
});

you can make format of parameters using where method:
Route::get('user/{name}', function ($name) {
    //
})->where('name', '[A-Za-z]+');

You can make global format to add pattern
public function boot()
{
    Route::pattern('id', '[0-9]+');

    parent::boot();
}

Route Prefixes:
Route::prefix('admin')->group(function () {
    Route::get('users', function () {
        // Matches The "/admin/users" URL
    });
});

Route Limiting:
60times join for 1 min
Route::middleware('auth:api', 'throttle:60,1')->group(function () {
    Route::get('/user', function () {
        //
    });
});

8/17
Middleware
Middleware provide a convenient mechanism for filtering HTTP requests entering your application.
Creating Middleware 
php artisan make:middleware CheckAge
You can create middleware using above command.
All Middlewares will place in App/HTTP/Middleware.
This is middleware example:
<?php

namespace App\Http\Middleware;

use Closure;

class CheckAge
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if ($request->age <= 200) {
            return redirect('home');
        }

        return $next($request);
    }
}

global middleware will be place in the $middleware property of your app/Http/Kernal.php class.
Assigning Middleware To Routes:
Route::get('admin/profile', function () {
    //
})->middleware('auth');
You may also assign multiple middleware to the route:

Route::get('/', function () {
    //
})->middleware('first', 'second');
We can use $middlewarePriority property of your app/Http/Kernel.php file for sort middleware order
Middleware parameters may be specified when defining the route by separating the middleware name and parameters with a :. Multiple parameters should be delimited by commas:

Route::put('post/{id}', function ($id) {
    //
})->middleware('role:editor');

8/18
CSRF Protection
CSRF is  Cross-site request forgeries. This is a type or malicious exploit whereby unuthorized commands
are performed on behalf of an authenticated user.
Anytime you define an HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field:
example: <form method="POST" action="/profile">
    @csrf
    ...
</form>
If you use axios HTTP library, this token generate automatically, but if not, you should add manually
If you want to except some uri from CSRF protection, you can user $except property of the VerifyCsrfToken middleware
example:
protected $except = [
        'stripe/*',
        'http://example.com/foo/bar',
        'http://example.com/foo/*',
    ];
X-CSRF-TOKEN
<meta name="csrf-token" content="{{ csrf_token() }}">
$.ajaxSetup({
    headers: {
        'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    }
});
There is X-XSRF-TOKEN too..

Controllers
Instead of defining all of your request handling logic as Closures in route files, you may wish to organize this behavior using Controller classes.
Controllers are stored in the app/Http/Controllers directory.
Basic Controllers
-Defining Controllers
-Controllers & Namespaces
-Single Action Controllers
Controller Middleware
Resource Controllers
-Partial Resource Routes
-Nested Resources
-Naming Resource Routes
-Naming Resource Route Parameters
-Scoping Resource Routes
-Localizing Resource URIs
-Supplementing Resource Controllers
Dependency Injection & Controllers
Route Caching
You can define a route to this controller action like so:
Route::get('user/{id}', 'UserController@show');
Namespaces: Route::get('foo', 'Photos\AdminController@method');
If you would like to define a controller that only handles a single action, you may place a single __invoke method on the controller:
example: public function __invoke($id)
    {
        return view('user.profile', ['user' => User::findOrFail($id)]);
    }
When registering routes for single action controllers, you do not need to specify a method:

Route::get('user/{id}', 'ShowProfile');
making invokable controller command: php artisan make:controller ShowProfile --invokable
Controller Middleware
Middleware may be assigned to the controller's routes in your route files:
Route::get('profile', 'UserController@show')->middleware('auth');
Using the make:controller Artisan command, we can quickly create such a controller:
php artisan make:controller PhotoController --resource
You may register many resource controllers at once by passing an array to the resources method:
Route::resources([
    'photos' => 'PhotoController',
    'posts' => 'PostController',
]);
php artisan make:controller PhotoController --resource --model=Photo
<form action="/foo/bar" method="POST">
    @method('PUT')
</form>
Naming Resource Route: Route::resource('photos', 'PhotoController')->names([
    'create' => 'photos.build'
]);
Route Caching
If you active route caching, router register speed will be 100X faster
generate cache: php artisan route:cache
remove cache: php artisan route:clear

8/18
Requests
Accessing The Request
-Request Path & Method
-PSR-7 Requests
Input Trimming & Normalization
Retrieving Input
-Old Input
-Cookies
Files
-Retrieving Uploaded Files
-Storing Uploaded Files

Retrieving The Request Path
The path method returns the request's path information. So, if the incoming request is targeted at http://domain.com/foo/bar, the path method will return foo/bar:
$uri = $request->path();

To retrieve the full URL for the incoming request you may use the url or fullUrl methods. The url method will return the URL without the query string, while the fullUrl method includes the query string:
$url = $request->url();
$url = $request->fullUrl();
Retrieving An Input Value
Using a few simple methods, you may access all of the user input from your Illuminate\Http\Request instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the input method may be used to retrieve user input:
$name = $request->input('name');
Multivalue is possible
Retrieving Input From The Query String
While the input method retrieves values from entire request payload (including the query string), the query method will only retrieve values from the query string:
$name = $request->query('name');
Multivalue is possible
Retrieving Input Via Dynamic Properties
$name = $request->name;
Retrieving JSON Input Values
$name = $request->input('user.name');
Retrieving Boolean Input Values
$archived = $request->boolean('archived');
Determining If An Input Value Is Present
if ($request->has('name')) {
    //
}
if ($request->filled('name')) {
    //
}
if ($request->missing('name')) {
    //
}
Retrieving Old Input
To retrieve flashed input from the previous request, use the old method on the Request instance. The old method will pull the previously flashed input data from the session:
$username = $request->old('username');
Attaching Cookies To Responses
return response('Hello World')->cookie(
    'name', 'value', $minutes
);
File Paths & Extensions
$path = $request->photo->path();
$extension = $request->photo->extension();
File storing
$path = $request->photo->store('images');
$path = $request->photo->store('images', 's3');
Configuring Trusted Proxies
protected $proxies = [
        '192.168.1.1',
        '192.168.1.2',
    ];
For all proxies, we can use '*'

8/20
HTTP Responses

Creating Responses
-Attaching Headers To Responses
-Attaching Cookies To Responses
-Cookies & Encryption
Redirects
-Redirecting To Named Routes
-Redirecting To Controller Actions
-Redirecting To External Domains
-Redirecting With Flashed Session Data
Other Response Types
-View Responses
-JSON Responses
-File Downloads
-File Responses
Response Macros

Creating Response
Route::get('/', function () {
    return 'Hello World';
});
response can be string and array, object.
Attach header and cookies to response
return response($content)
                ->header('Content-Type', $type)
                ->cookie('name', 'value', $minutes);
Redirect
Route::get('dashboard', function () {
    return redirect('home/dashboard');
});
Redirecting To Named Routes
return redirect()->route('login');
Redirecting To Controller Actions
return redirect()->action('HomeController@index');
Redirecting To External Domains
return redirect()->away('https://www.google.com');
View Responses
return response()
            ->view('hello', $data, 200)
            ->header('Content-Type', $type);
JSON Responses
return response()->json([
    'name' => 'Abigail',
    'state' => 'CA',
]);
File Downloads
return response()->download($pathToFile);
return response()->download($pathToFile, $name, $headers);
return response()->download($pathToFile)->deleteFileAfterSend();

Streamed Downloads
return response()->streamDownload(function () {
    echo GitHub::api('repo')
                ->contents()
                ->readme('laravel', 'laravel')['contents'];
}, 'laravel-readme.md');
File Responses
return response()->file($pathToFile);
return response()->file($pathToFile, $headers);
Response Macros
If you would like to define a custom response that you can re-use in a variety of your routes and controllers, you may use the macro method on the Response facade. For example, from a service provider's boot method:

8/21
Views
Creating Views
Passing Data To Views
-Sharing Data With All Views
View Composers
Optimizing Views

Views are stored in the resources/views directory.
<html>
    <body>
        <h1>Hello, {{ $name }}</h1>
    </body>
</html>
Route::get('/', function () {
    return view('greeting', ['name' => 'James']);
});
"Dot" notation may be used to reference nested views. For example, if your view is stored at resources/views/admin/profile.blade.php, you may reference it like so:
return view('admin.profile', $data);
If you need to determine if a view exists, you may use the View facade. The exists method will return true if the view exists:
use Illuminate\Support\Facades\View;
if (View::exists('emails.customer')) {
    //
}
Passing Data To Views
return view('greetings', ['name' => 'Victoria']);
return view('greeting')->with('name', 'Victoria');
Sharing Data With All Views
public function boot()
    {
        View::share('key', 'value');
    }
View Composers
public function boot()
    {
        // Using class based composers...
        View::composer(
            'profile', 'App\Http\View\Composers\ProfileComposer'
        );

        // Using Closure based composers...
        View::composer('dashboard', function ($view) {
            //
        });
    }
Attaching A Composer To Multiple Views
View::composer(
    ['profile', 'dashboard'],
    'App\Http\View\Composers\MyViewComposer'
);
View::composer('*', function ($view) {
    //
});
View Createors
View::creator('profile', 'App\Http\View\Creators\ProfileCreator');
Optimizing Views
Compiling views during the request negatively impacts performance, so Laravel provides the view:cache Artisan command to precompile all of the views utilized by your application
php artisan view:cache
You may use the view:clear command to clear the view cache:
php artisan view:clear

8/23
URL Generation
Introduction
The Basics
-Generating Basic URLs
-Accessing The Current URL
URLs For Named Routes
-Signed URLs

URLs For Controller Actions
Default Values
The url helper may be used to generate arbitrary URLs for your application.
$post = App\Post::find(1);
echo url("/posts/{$post->id}");

Accessing The Current URL
echo url()->current();
echo url()->full();
echo url()->previous();
echo URL::current();

URLs For Named Routes
Route::get('/post/{post}', function () {
    //
})->name('post.show');
echo route('post.show', ['post' => 1]);
echo route('post.show', ['post' => $post]);
Route::get('/post/{post}/comment/{comment}', function () {
    //
})->name('comment.show');
echo route('comment.show', ['post' => 1, 'comment' => 3]);

Signed URLs
use Illuminate\Support\Facades\URL;
return URL::signedRoute('unsubscribe', ['user' => 1]);
use Illuminate\Support\Facades\URL;
return URL::temporarySignedRoute(
    'unsubscribe', now()->addMinutes(30), ['user' => 1]
);
-Validating Signed Route Requests
use Illuminate\Http\Request;
Route::get('/unsubscribe/{user}', function (Request $request) {
    if (! $request->hasValidSignature()) {
        abort(401);
    }
    // ...
})->name('unsubscribe');
protected $routeMiddleware = [
    'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
];
Route::post('/unsubscribe/{user}', function (Request $request) {
    // ...
})->name('unsubscribe')->middleware('signed');

URLs For Controller Actions
$url = action('HomeController@index');
use App\Http\Controllers\HomeController;
$url = action([HomeController::class, 'index']);
$url = action('UserController@profile', ['id' => 1]);

Default Values
Route::get('/{locale}/posts', function () {
    //
})->name('post.index');
It is cumbersome to always pass the locale every time you call the route helper. So, you may use the URL::defaults method to define a default value for this parameter that will always be applied during the current request. You may wish to call this method from a route middleware so that you have access to the current request:
<?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Support\Facades\URL;

class SetDefaultLocaleForUrls
{
    public function handle($request, Closure $next)
    {
        URL::defaults(['locale' => $request->user()->locale]);

        return $next($request);
    }
}