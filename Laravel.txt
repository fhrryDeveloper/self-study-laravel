8/13
I studied about Routing in Laravel
basic routes: Route:get('foo', function(){return "success!";})

multiple router:
Route::match(['get', 'post'], '/', function () {
    //
});

Route::any('/', function () {
    //
});

CSRF protection: 
<form method="POST" action="/profile">
    @csrf
    ...
</form>
if you don't use @csrf, it will be rejected

Redirect Route: Route::redirect('/here', '/there');

When you need only view, you can use view: Route::view('/welcome', 'welcome');

Also you can send parameter: Route::get('user/{id}', function ($id) {
    return 'User '.$id;
});

you can make format of parameters using where method:
Route::get('user/{name}', function ($name) {
    //
})->where('name', '[A-Za-z]+');

You can make global format to add pattern
public function boot()
{
    Route::pattern('id', '[0-9]+');

    parent::boot();
}

Route Prefixes:
Route::prefix('admin')->group(function () {
    Route::get('users', function () {
        // Matches The "/admin/users" URL
    });
});

Route Limiting:
60times join for 1 min
Route::middleware('auth:api', 'throttle:60,1')->group(function () {
    Route::get('/user', function () {
        //
    });
});

8/17
Middleware
Middleware provide a convenient mechanism for filtering HTTP requests entering your application.
Creating Middleware 
php artisan make:middleware CheckAge
You can create middleware using above command.
All Middlewares will place in App/HTTP/Middleware.
This is middleware example:
<?php

namespace App\Http\Middleware;

use Closure;

class CheckAge
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if ($request->age <= 200) {
            return redirect('home');
        }

        return $next($request);
    }
}

global middleware will be place in the $middleware property of your app/Http/Kernal.php class.
Assigning Middleware To Routes:
Route::get('admin/profile', function () {
    //
})->middleware('auth');
You may also assign multiple middleware to the route:

Route::get('/', function () {
    //
})->middleware('first', 'second');
We can use $middlewarePriority property of your app/Http/Kernel.php file for sort middleware order
Middleware parameters may be specified when defining the route by separating the middleware name and parameters with a :. Multiple parameters should be delimited by commas:

Route::put('post/{id}', function ($id) {
    //
})->middleware('role:editor');

8/18
CSRF Protection
CSRF is  Cross-site request forgeries. This is a type or malicious exploit whereby unuthorized commands
are performed on behalf of an authenticated user.
Anytime you define an HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field:
example: <form method="POST" action="/profile">
    @csrf
    ...
</form>
If you use axios HTTP library, this token generate automatically, but if not, you should add manually
If you want to except some uri from CSRF protection, you can user $except property of the VerifyCsrfToken middleware
example:
protected $except = [
        'stripe/*',
        'http://example.com/foo/bar',
        'http://example.com/foo/*',
    ];
X-CSRF-TOKEN
<meta name="csrf-token" content="{{ csrf_token() }}">
$.ajaxSetup({
    headers: {
        'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    }
});
There is X-XSRF-TOKEN too..

Controllers
Instead of defining all of your request handling logic as Closures in route files, you may wish to organize this behavior using Controller classes.
Controllers are stored in the app/Http/Controllers directory.
Basic Controllers
-Defining Controllers
-Controllers & Namespaces
-Single Action Controllers
Controller Middleware
Resource Controllers
-Partial Resource Routes
-Nested Resources
-Naming Resource Routes
-Naming Resource Route Parameters
-Scoping Resource Routes
-Localizing Resource URIs
-Supplementing Resource Controllers
Dependency Injection & Controllers
Route Caching
You can define a route to this controller action like so:
Route::get('user/{id}', 'UserController@show');
Namespaces: Route::get('foo', 'Photos\AdminController@method');
If you would like to define a controller that only handles a single action, you may place a single __invoke method on the controller:
example: public function __invoke($id)
    {
        return view('user.profile', ['user' => User::findOrFail($id)]);
    }
When registering routes for single action controllers, you do not need to specify a method:

Route::get('user/{id}', 'ShowProfile');
making invokable controller command: php artisan make:controller ShowProfile --invokable
Controller Middleware
Middleware may be assigned to the controller's routes in your route files:
Route::get('profile', 'UserController@show')->middleware('auth');
Using the make:controller Artisan command, we can quickly create such a controller:
php artisan make:controller PhotoController --resource
You may register many resource controllers at once by passing an array to the resources method:
Route::resources([
    'photos' => 'PhotoController',
    'posts' => 'PostController',
]);
php artisan make:controller PhotoController --resource --model=Photo
<form action="/foo/bar" method="POST">
    @method('PUT')
</form>
Naming Resource Route: Route::resource('photos', 'PhotoController')->names([
    'create' => 'photos.build'
]);
Route Caching
If you active route caching, router register speed will be 100X faster
generate cache: php artisan route:cache
remove cache: php artisan route:clear

8/18
Requests
Accessing The Request
-Request Path & Method
-PSR-7 Requests
Input Trimming & Normalization
Retrieving Input
-Old Input
-Cookies
Files
-Retrieving Uploaded Files
-Storing Uploaded Files

Retrieving The Request Path
The path method returns the request's path information. So, if the incoming request is targeted at http://domain.com/foo/bar, the path method will return foo/bar:
$uri = $request->path();

To retrieve the full URL for the incoming request you may use the url or fullUrl methods. The url method will return the URL without the query string, while the fullUrl method includes the query string:
$url = $request->url();
$url = $request->fullUrl();
Retrieving An Input Value
Using a few simple methods, you may access all of the user input from your Illuminate\Http\Request instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the input method may be used to retrieve user input:
$name = $request->input('name');
Multivalue is possible
Retrieving Input From The Query String
While the input method retrieves values from entire request payload (including the query string), the query method will only retrieve values from the query string:
$name = $request->query('name');
Multivalue is possible
Retrieving Input Via Dynamic Properties
$name = $request->name;
Retrieving JSON Input Values
$name = $request->input('user.name');
Retrieving Boolean Input Values
$archived = $request->boolean('archived');
Determining If An Input Value Is Present
if ($request->has('name')) {
    //
}
if ($request->filled('name')) {
    //
}
if ($request->missing('name')) {
    //
}
Retrieving Old Input
To retrieve flashed input from the previous request, use the old method on the Request instance. The old method will pull the previously flashed input data from the session:
$username = $request->old('username');
Attaching Cookies To Responses
return response('Hello World')->cookie(
    'name', 'value', $minutes
);
File Paths & Extensions
$path = $request->photo->path();
$extension = $request->photo->extension();
File storing
$path = $request->photo->store('images');
$path = $request->photo->store('images', 's3');
Configuring Trusted Proxies
protected $proxies = [
        '192.168.1.1',
        '192.168.1.2',
    ];
For all proxies, we can use '*'

8/20
HTTP Responses

Creating Responses
-Attaching Headers To Responses
-Attaching Cookies To Responses
-Cookies & Encryption
Redirects
-Redirecting To Named Routes
-Redirecting To Controller Actions
-Redirecting To External Domains
-Redirecting With Flashed Session Data
Other Response Types
-View Responses
-JSON Responses
-File Downloads
-File Responses
Response Macros

Creating Response
Route::get('/', function () {
    return 'Hello World';
});
response can be string and array, object.
Attach header and cookies to response
return response($content)
                ->header('Content-Type', $type)
                ->cookie('name', 'value', $minutes);
Redirect
Route::get('dashboard', function () {
    return redirect('home/dashboard');
});
Redirecting To Named Routes
return redirect()->route('login');
Redirecting To Controller Actions
return redirect()->action('HomeController@index');
Redirecting To External Domains
return redirect()->away('https://www.google.com');
View Responses
return response()
            ->view('hello', $data, 200)
            ->header('Content-Type', $type);
JSON Responses
return response()->json([
    'name' => 'Abigail',
    'state' => 'CA',
]);
File Downloads
return response()->download($pathToFile);
return response()->download($pathToFile, $name, $headers);
return response()->download($pathToFile)->deleteFileAfterSend();

Streamed Downloads
return response()->streamDownload(function () {
    echo GitHub::api('repo')
                ->contents()
                ->readme('laravel', 'laravel')['contents'];
}, 'laravel-readme.md');
File Responses
return response()->file($pathToFile);
return response()->file($pathToFile, $headers);
Response Macros
If you would like to define a custom response that you can re-use in a variety of your routes and controllers, you may use the macro method on the Response facade. For example, from a service provider's boot method:

8/21
Views
Creating Views
Passing Data To Views
-Sharing Data With All Views
View Composers
Optimizing Views

Views are stored in the resources/views directory.
<html>
    <body>
        <h1>Hello, {{ $name }}</h1>
    </body>
</html>
Route::get('/', function () {
    return view('greeting', ['name' => 'James']);
});
"Dot" notation may be used to reference nested views. For example, if your view is stored at resources/views/admin/profile.blade.php, you may reference it like so:
return view('admin.profile', $data);
If you need to determine if a view exists, you may use the View facade. The exists method will return true if the view exists:
use Illuminate\Support\Facades\View;
if (View::exists('emails.customer')) {
    //
}
Passing Data To Views
return view('greetings', ['name' => 'Victoria']);
return view('greeting')->with('name', 'Victoria');
Sharing Data With All Views
public function boot()
    {
        View::share('key', 'value');
    }
View Composers
public function boot()
    {
        // Using class based composers...
        View::composer(
            'profile', 'App\Http\View\Composers\ProfileComposer'
        );

        // Using Closure based composers...
        View::composer('dashboard', function ($view) {
            //
        });
    }
Attaching A Composer To Multiple Views
View::composer(
    ['profile', 'dashboard'],
    'App\Http\View\Composers\MyViewComposer'
);
View::composer('*', function ($view) {
    //
});
View Createors
View::creator('profile', 'App\Http\View\Creators\ProfileCreator');
Optimizing Views
Compiling views during the request negatively impacts performance, so Laravel provides the view:cache Artisan command to precompile all of the views utilized by your application
php artisan view:cache
You may use the view:clear command to clear the view cache:
php artisan view:clear

8/23
URL Generation
Introduction
The Basics
-Generating Basic URLs
-Accessing The Current URL
URLs For Named Routes
-Signed URLs

URLs For Controller Actions
Default Values
The url helper may be used to generate arbitrary URLs for your application.
$post = App\Post::find(1);
echo url("/posts/{$post->id}");

Accessing The Current URL
echo url()->current();
echo url()->full();
echo url()->previous();
echo URL::current();

URLs For Named Routes
Route::get('/post/{post}', function () {
    //
})->name('post.show');
echo route('post.show', ['post' => 1]);
echo route('post.show', ['post' => $post]);
Route::get('/post/{post}/comment/{comment}', function () {
    //
})->name('comment.show');
echo route('comment.show', ['post' => 1, 'comment' => 3]);

Signed URLs
use Illuminate\Support\Facades\URL;
return URL::signedRoute('unsubscribe', ['user' => 1]);
use Illuminate\Support\Facades\URL;
return URL::temporarySignedRoute(
    'unsubscribe', now()->addMinutes(30), ['user' => 1]
);
-Validating Signed Route Requests
use Illuminate\Http\Request;
Route::get('/unsubscribe/{user}', function (Request $request) {
    if (! $request->hasValidSignature()) {
        abort(401);
    }
    // ...
})->name('unsubscribe');
protected $routeMiddleware = [
    'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
];
Route::post('/unsubscribe/{user}', function (Request $request) {
    // ...
})->name('unsubscribe')->middleware('signed');

URLs For Controller Actions
$url = action('HomeController@index');
use App\Http\Controllers\HomeController;
$url = action([HomeController::class, 'index']);
$url = action('UserController@profile', ['id' => 1]);

Default Values
Route::get('/{locale}/posts', function () {
    //
})->name('post.index');
It is cumbersome to always pass the locale every time you call the route helper. So, you may use the URL::defaults method to define a default value for this parameter that will always be applied during the current request. You may wish to call this method from a route middleware so that you have access to the current request:
<?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Support\Facades\URL;

class SetDefaultLocaleForUrls
{
    public function handle($request, Closure $next)
    {
        URL::defaults(['locale' => $request->user()->locale]);

        return $next($request);
    }
}

8/24
HTTP Session
Introduction
-Configuration
-Driver Prerequisites
Using The Session
-Retrieving Data
-Storing Data
-Flash Data
-Deleting Data
-Regenerating The Session ID
Session Blocking
Adding Custom Session Drivers
-Implementing The Driver
-Registering The Driver

8/25
8/27
file - sessions are stored in storage/framework/sessions.
cookie - sessions are stored in secure, encrypted cookies.
database - sessions are stored in a relational database.
memcached / redis - sessions are stored in one of these fast, cache based stores.
array - sessions are stored in a PHP array and will not be persisted.

Database
Schema::create('sessions', function ($table) {
    $table->string('id')->unique();
    $table->foreignId('user_id')->nullable();
    $table->string('ip_address', 45)->nullable();
    $table->text('user_agent')->nullable();
    $table->text('payload');
    $table->integer('last_activity');
});

Redis
Before using Redis sessions with Laravel, you will need to either install the PhpRedis PHP extension via PECL or install the predis/predis package (~1.0) via Composer.

Retrieving Data
$value = $request->session()->get('key');
$value = $request->session()->get('key', 'default');
$value = $request->session()->get('key', function () {
    return 'default';
});
The Global Session Helper
 $value = session('key');
 $value = session('key', 'default');
 session(['key' => 'value']);
Retrieving All Session Data
$data = $request->session()->all();
Determining If An Item Exists In The Session
if ($request->session()->has('users')) {
    //
}
Storing Data
$request->session()->put('key', 'value');
session(['key' => 'value']);
Pushing To Array Session Values
$request->session()->push('user.teams', 'developers');
Retrieving & Deleting An Item
$value = $request->session()->pull('key', 'default')
Flash Data
$request->session()->flash('status', 'Task was successful!');
Deleting Data
$request->session()->forget('key');
$request->session()->forget(['key1', 'key2']);
$request->session()->flush();
Regenerating The Session ID
$request->session()->regenerate();
Session Blocking
Route::post('/profile', function () {
})->block($lockSeconds = 10, $waitSeconds = 10)
Route::post('/order', function () {
})->block($lockSeconds = 10, $waitSeconds = 10)
Implementing The Driver
class MongoSessionHandler implements \SessionHandlerInterface
{
    public function open($savePath, $sessionName) {}
    public function close() {}
    public function read($sessionId) {}
    public function write($sessionId, $data) {}
    public function destroy($sessionId) {}
    public function gc($lifetime) {}
}
Registering The Driver
 Session::extend('mongo', function ($app) {
            // Return implementation of SessionHandlerInterface...
            return new MongoSessionHandler;
        });
8/30, 8/31
Validation

Introduction
Validation Quickstart
-Defining The Routes
-Creating The Controller
-Writing The Validation Logic
-Displaying The Validation Errors
-A Note On Optional Fields
Form Request Validation
-Creating Form Requests
-Authorizing Form Requests
-Customizing The Error Messages
-Customizing The Validation Attributes
-Prepare Input For Validation
Manually Creating Validators
-Automatic Redirection
-Named Error Bags
-After Validation Hook
Working With Error Messages
-Custom Error Messages
Available Validation Rules
Conditionally Adding Rules
Validating Arrays
Custom Validation Rules
-Using Rule Objects
-Using Closures
-Using Extensions
-Implicit Extensions
Laravel provides several different approaches to validate your application's incoming data. By default, Laravel's base controller class uses a ValidatesRequests trait which provides a convenient method to validate incoming HTTP requests with a variety of powerful validation rules.
Defining The Routes
First, let's assume we have the following routes defined in our routes/web.php file:
Route::get('post/create', 'PostController@create');
Route::post('post', 'PostController@store');
Writing The Validation Logic
public function store(Request $request)
{
    $validatedData = $request->validate([
        'title' => 'required|unique:posts|max:255',
        'body' => 'required',
    ]);
}
A Note On Nested Attributes
$request->validate([
    'title' => 'required|unique:posts|max:255',
    'author.name' => 'required',
    'author.description' => 'required',
]);
Customizing The Validation Attributes
public function attributes()
{
    return [
        'email' => 'email address',
    ];
}
Prepare Input For Validation
protected function prepareForValidation()
{
    $this->merge([
        'slug' => Str::slug($this->slug),
    ]);
}
Manually Creating Validators
 public function store(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ]);

        if ($validator->fails()) {
            return redirect('post/create')
                        ->withErrors($validator)
                        ->withInput();
        }
    }
Automatic Redirection
Validator::make($request->all(), [
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
])->validate();
Validator::make($request->all(), [
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
])->validateWithBag('post');

Error Handling
Introduction
Configuration
The Exception Handler
-Report Method
-Render Method
-Reportable & Renderable Exceptions
HTTP Exceptions
-Custom HTTP Error Pages

Introduction
The App\Exceptions\Handler class is where all exceptions triggered by your application are logged and then rendered back to the user.

Configuration
If you set the APP_DEBUG environment variable to true, you can enable debug option.

The Exception Handler
-The Report Method
  if ($exception instanceof CustomException) {
        //
    }
    parent::report($exception);
 1.Global Log Context
 2.The report Helper
 3.Ignoring Exceptions By Type
-The Render Method
public function render($request, Throwable $exception)
{
    if ($exception instanceof CustomException) {
        return response()->view('errors.custom', [], 500);
    }

    return parent::render($request, $exception);
}
-Reportable & Renderable Exceptions
HTTP Exceptions
In order to generate such a response from anywhere in your application, you may use the abort helper:
abort(403, 'Unauthorized action.');
-Custom HTTP Error Pages
If you wish to customize the error page for 404 HTTP status codes, create a resources/views/errors/404.blade.php. 
<h2>{{ $exception->getMessage() }}</h2>
You may publish Laravel's error page templates using the vendor:publish Artisan command. Once the templates have been published, you may customize them to your liking:

php artisan vendor:publish --tag=laravel-errors

9/2
Logging
Introduction
Configuration
-Building Log Stacks
Writing Log Messages
-Writing To Specific Channels
Advanced Monolog Channel Customization
-Customizing Monolog For Channels
-Creating Monolog Handler Channels
-Creating Channels Via Factories

Introduction
To help you learn more about what's happening within your application, Laravel provides robust logging services that allow you to log messages to files, the system error log, and even to Slack to notify your entire team.
Monolog library

Configuration
All of the configuration for your application's logging system is housed in the config/logging.php configuration file. 

Configuring The Channel Name
'stack' => [
    'driver' => 'stack',
    'name' => 'channel-name',
    'channels' => ['single', 'slack'],
],

Writing Log Messages
Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);
Creating Monolog Handler Channels
'logentries' => [
    'driver'  => 'monolog',
    'handler' => Monolog\Handler\SyslogUdpHandler::class,
    'with' => [
        'host' => 'my.logentries.internal.datahubhost.company.com',
        'port' => '10000',
    ],
],
Monolog Formatters
'browser' => [
    'driver' => 'monolog',
    'handler' => Monolog\Handler\BrowserConsoleHandler::class,
    'formatter' => Monolog\Formatter\HtmlFormatter::class,
    'formatter_with' => [
        'dateFormat' => 'Y-m-d',
    ],
],
'newrelic' => [
    'driver' => 'monolog',
    'handler' => Monolog\Handler\NewRelicHandler::class,
    'formatter' => 'default',
],
Creating Channels Via Factories
'channels' => [
    'custom' => [
        'driver' => 'custom',
        'via' => App\Logging\CreateCustomLogger::class,
    ],
],
Once you have configured the custom channel, you're ready to define the class that will create your Monolog instance. This class only needs a single method: __invoke, which should return the Monolog instance:
class CreateCustomLogger
{
    public function __invoke(array $config)
    {
        return new Logger(...);
    }
}
9/3, 9/4
Blade Templates

Introduction
Template Inheritance
-Defining A Layout
-Extending A Layout
Displaying Data
-Blade & JavaScript Frameworks
Control Structures
-If Statements
-Switch Statements
-Loops
-The Loop Variable
-Comments
-PHP
-The @once Directive
Forms
-CSRF Field
-Method Field
-Validation Errors
Components
-Displaying Components
-Passing Data To Components
-Managing Attributes
-Slots
-Inline Component Views
-Anonymous Components
Including Subviews
-Rendering Views For Collections
Stacks
Service Injection
Extending Blade
-Custom If Statements

9/6, 9/7
Localization

Introduction
-Configuring The Locale
Defining Translation Strings
-Using Short Keys
-Using Translation Strings As Keys
Retrieving Translation Strings
-Replacing Parameters In Translation Strings
-Pluralization
Overriding Package Language Files

Introduction
Laravel's localization features provide a convenient way to retrieve strings in various languages, allowing you to easily support multiple languages within your application. Language strings are stored in files within the resources/lang directory. Within this directory there should be a subdirectory for each language supported by the application
example:
/resources
    /lang
        /en
            messages.php
        /es
            messages.php
All language files return an array of keyed strings. 
return [
    'welcome' => 'Welcome to our application',
];
Configuring The Locale(config/app.php)
Route::get('welcome/{locale}', function ($locale) {
    if (! in_array($locale, ['en', 'es', 'fr'])) {
        abort(400);
    }
    App::setLocale($locale);
});
You may configure a "fallback language", which will be used when the active language does not contain a given translation string. 
'fallback_locale' => 'en',
Determining The Current Locale
You may use the getLocale and isLocale methods on the App facade to determine the current locale or check if the locale is a given value:

$locale = App::getLocale();

if (App::isLocale('en')) {
    //
}
Defining Translation Strings
-Using Short Keys
Typically, translation strings are stored in files within the resources/lang directory.
/resources
    /lang
        /en
            messages.php
        /es
            messages.php
return [
    'welcome' => 'Welcome to our application',
];
Using Translation Strings As Keys
Translation files that use translation strings as keys are stored as JSON files in the resources/lang directory. For example, if your application has a Spanish translation, you should create a resources/lang/es.json file:
{
    "I love programming.": "Me encanta programar."
}
Retrieving Translation Strings
You may retrieve lines from language files using the __ helper function.
echo __('messages.welcome');
echo __('I love programming.');
If you are using the Blade templating engine, you may use the {{ }} syntax to echo the translation string or use the @lang directive:
{{ __('messages.welcome') }}
@lang('messages.welcome')
Replacing Parameters In Translation Strings
'welcome' => 'Welcome, :name',
echo __('messages.welcome', ['name' => 'dayle']);
'welcome' => 'Welcome, :NAME', // Welcome, DAYLE
'goodbye' => 'Goodbye, :Name', // Goodbye, Dayle
Pluralization
Pluralization is a complex problem, as different languages have a variety of complex rules for pluralization.
'apples' => 'There is one apple|There are many apples',
'apples' => '{0} There are none|[1,19] There are some|[20,*] There are many',
echo trans_choice('messages.apples', 10);
'minutes_ago' => '{1} :value minute ago|[2,*] :value minutes ago',
echo trans_choice('time.minutes_ago', 5, ['value' => 5]);
'apples' => '{0} There are none|{1} There is one|[2,*] There are :count',

Overriding Package Language Files
Some packages may ship with their own language files. Instead of changing the package's core files to tweak these lines, you may override them by placing files in the resources/lang/vendor/{package}/{locale} directory.

9/8
JavaScript & CSS Scaffolding

Introduction
Writing CSS
Writing JavaScript
-Writing Vue Components
-Using React
Adding Presets

The Bootstrap and Vue scaffolding provided by Laravel is located in the laravel/ui Composer package, which may be installed using Composer:
composer require laravel/ui:^2.4

Once the laravel/ui package has been installed, you may install the frontend scaffolding using the ui Artisan command:

// Generate basic scaffolding...
php artisan ui bootstrap
php artisan ui vue
php artisan ui react

// Generate login / registration scaffolding...
php artisan ui bootstrap --auth
php artisan ui vue --auth
php artisan ui react --auth
Laravel does include some basic scaffolding to make it easier to get started writing modern JavaScript using the Vue library.
Before compiling your CSS, install your project's frontend dependencies using the Node package manager (NPM):
npm install
Writing CSS
Once the dependencies have been installed using npm install, you can compile your SASS files to plain CSS using Laravel Mix. The npm run dev command will process the instructions in your webpack.mix.js file. Typically, your compiled CSS will be placed in the public/css directory:
npm run dev
Writing JavaScript
npm install
Once the packages are installed, you can use the npm run dev command to compile your assets. Webpack is a module bundler for modern JavaScript applications. When you run the npm run dev command, Webpack will execute the instructions in your webpack.mix.js file:
npm run dev
Writing Vue Components
When using the laravel/ui package to scaffold your frontend, an ExampleComponent.vue Vue component will be placed in the resources/js/components directory. 
Vue.component(
    'example-component',
    require('./components/ExampleComponent.vue').default
);
@extends('layouts.app')

@section('content')
    <example-component></example-component>
@endsection
Using React
If you prefer to use React to build your JavaScript application, Laravel makes it a cinch to swap the Vue scaffolding with React scaffolding:

composer require laravel/ui

// Generate basic scaffolding...
php artisan ui react

// Generate login / registration scaffolding...
php artisan ui react --auth
Adding Presets
Typically, you should declare preset macros in a service provider:

use Laravel\Ui\UiCommand;

UiCommand::macro('nextjs', function (UiCommand $command) {
    // Scaffold your frontend...
});
Then, you may call the new preset via the ui command:

php artisan ui nextjs

9/10
9/13
Compiling Assets (Mix)
Introduction
Installation & Setup
Running Mix
Working With Stylesheets
-Less
-Sass
-Stylus
-PostCSS
-Plain CSS
-URL Processing
-Source Maps
Working With JavaScript
-Vendor Extraction
-React
-Vanilla JS
-Custom Webpack Configuration
Copying Files & Directories
Versioning / Cache Busting
Browsersync Reloading
Environment Variables
Notifications

Introduction
Laravel Mix provides a fluent API for defining Webpack build steps for your Laravel application using several common CSS and JavaScript pre-processors. Through simple method chaining, you can fluently define your asset pipeline. For example:

mix.js('resources/js/app.js', 'public/js')
    .sass('resources/sass/app.scss', 'public/css');
Installation & Setup
npm install
Running Mix
npm run dev
npm run production
npm run watch
Working With Stylesheets
The webpack.mix.js file is your entry point for all asset compilation. Think of it as a light configuration wrapper around Webpack. Mix tasks can be chained together to define exactly how your assets should be compiled.
Less
The less method may be used to compile Less into CSS. Let's compile our primary app.less file to public/css/app.css.
mix.less('resources/less/app.less', 'public/css');
mix.less('resources/less/app.less', 'public/css')
    .less('resources/less/admin.less', 'public/css');
Sass
The sass method allows you to compile Sass into CSS. You may use the method like so:
mix.sass('resources/sass/app.scss', 'public/css');
Stylus
Similar to Less and Sass, the stylus method allows you to compile Stylus into CSS:
mix.stylus('resources/stylus/app.styl', 'public/css');
Source Maps
Though disabled by default, source maps may be activated by calling the mix.sourceMaps() method in your webpack.mix.js file. Though it comes with a compile/performance cost, this will provide extra debugging information to your browser's developer tools when using compiled assets.

mix.js('resources/js/app.js', 'public/js')
    .sourceMaps();
Merging Custom Configuration
Mix provides a useful webpackConfig method that allows you to merge any short Webpack configuration overrides. 
mix.webpackConfig({
    resolve: {
        modules: [
            path.resolve(__dirname, 'vendor/laravel/spark/resources/assets/js')
        ]
    }
});
Copying Files & Directories
The copy method may be used to copy files and directories to new locations. This can be useful when a particular asset within your node_modules directory needs to be relocated to your public folder.

mix.copy('node_modules/foo/bar.css', 'public/css/bar.css');
Custom Mix Base URLs
If your Mix compiled assets are deployed to a CDN separate from your application, you will need to change the base URL generated by the mix function. You may do so by adding a mix_url configuration option to your config/app.php configuration file:

'mix_url' => env('MIX_ASSET_URL', null)
Browsersync Reloading
BrowserSync can automatically monitor your files for changes, and inject your changes into the browser without requiring a manual refresh. You may enable support by calling the mix.browserSync() method:

mix.browserSync('my-domain.test');
Environment Variables
In .env file
MIX_SENTRY_DSN_PUBLIC=http://example.com
process.env.MIX_SENTRY_DSN_PUBLIC
Notifications
When available, Mix will automatically display OS notifications for each bundle.
mix.disableNotifications();
9/14, 9/15
Authentication

Introduction
-Database Considerations
Authentication Quickstart
-Routing
-Views
-Authenticating
-Retrieving The Authenticated User
-Protecting Routes
-Password Confirmation
-Login Throttling
Manually Authenticating Users
-Remembering Users
-Other Authentication Methods
HTTP Basic Authentication
-Stateless HTTP Basic Authentication
Logging Out
-Invalidating Sessions On Other Devices
Social Authentication
Adding Custom Guards
-Closure Request Guards
Adding Custom User Providers
-The User Provider Contract
-The Authenticatable Contract
Events

Introduction
The authentication configuration file is located at config/auth.php, which contains several well documented options for tweaking the behavior of the authentication services.

Database Considerations
By default, Laravel includes an App\User Eloquent model in your app directory. This model may be used with the default Eloquent authentication driver. 

Authentication Quickstart
Routing
Laravel's laravel/ui package provides a quick way to scaffold all of the routes and views you need for authentication using a few simple commands:

composer require laravel/ui:^2.4
php artisan ui vue --auth

Creating Applications Including Authentication
laravel new blog --auth

Views
As mentioned in the previous section, the laravel/ui package's php artisan ui vue --auth command will create all of the views you need for authentication and place them in the resources/views/auth directory.
Authenticating
You can customize the post-authentication redirect path using the HOME constant defined in your RouteServiceProvider:

public const HOME = '/home';
protected function authenticated(Request $request, $user)
{
    return response([
        //
    ]);
}
Username Customization
public function username()
{
    return 'username';
}
Guard Customization
use Illuminate\Support\Facades\Auth;

protected function guard()
{
    return Auth::guard('guard-name');
}
Retrieving The Authenticated User
use Illuminate\Support\Facades\Auth;
$user = Auth::user();
$id = Auth::id();
Determining If The Current User Is Authenticated
if (Auth::check()) {
    // The user is logged in...
}
Protecting Routes
Route middleware can be used to only allow authenticated users to access a given route. 
Route::get('profile', function () {
    // Only authenticated users may enter...
})->middleware('auth');
public function __construct()
{
    $this->middleware('auth');
}
Redirecting Unauthenticated Users
protected function redirectTo($request)
{
    return route('login');
}
Specifying A Guard
public function __construct()
{
    $this->middleware('auth:api');
}
Password Confirmation
Route::get('/settings/security', function () {
    // Users must confirm their password before continuing...
})->middleware(['auth', 'password.confirm']);
Login Throttling
If you are using Laravel's built-in LoginController class, the Illuminate\Foundation\Auth\ThrottlesLogins trait will already be included in your controller. 
Manually Authenticating Users
 public function authenticate(Request $request)
    {
        $credentials = $request->only('email', 'password');

        if (Auth::attempt($credentials)) {
            // Authentication passed...
            return redirect()->intended('dashboard');
        }
    }
Specifying Additional Conditions
if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {
    // The user is active, not suspended, and exists.
}
Accessing Specific Guard Instances
if (Auth::guard('admin')->attempt($credentials)) {
    //
}
Logging Out Auth::logout();

Other Authentication Methods
Authenticate A User Instance
Auth::login($user);
Auth::login($user, true);

Authenticate A User By ID
Auth::loginUsingId(1);
Auth::loginUsingId(1, true);

Authenticate A User Once
if (Auth::once($credentials)) {
    //
}

HTTP Basic Authentication
Route::get('profile', function () {
    // Only authenticated users may enter...
})->middleware('auth.basic');

A Note On FastCGI
RewriteCond %{HTTP:Authorization} ^(.+)$
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]

Stateless HTTP Basic Authentication
public function handle($request, $next)
    {
        return Auth::onceBasic() ?: $next($request);
    }

Route::get('api/user', function () {
    // Only authenticated users may enter...
})->middleware('auth.basic.once');

Logging Out
use Illuminate\Support\Facades\Auth;
Auth::logout();
Invalidating Sessions On Other Devices
'web' => [
    // ...
    \Illuminate\Session\Middleware\AuthenticateSession::class,
    // ...
],
use Illuminate\Support\Facades\Auth;
Auth::logoutOtherDevices($password);

Adding Custom Guards
<?php

namespace App\Providers;

use App\Services\Auth\JwtGuard;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Auth;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * Register any application authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this->registerPolicies();

        Auth::extend('jwt', function ($app, $name, array $config) {
            // Return an instance of Illuminate\Contracts\Auth\Guard...

            return new JwtGuard(Auth::createUserProvider($config['provider']));
        });
    }
}

public function boot()
{
    $this->registerPolicies();

    Auth::viaRequest('custom-token', function ($request) {
        return User::where('token', $request->token)->first();
    });
}
'guards' => [
    'api' => [
        'driver' => 'custom-token',
    ],
],
Adding Custom User Providers
public function boot()
    {
        $this->registerPolicies();

        Auth::provider('riak', function ($app, array $config) {
            // Return an instance of Illuminate\Contracts\Auth\UserProvider...

            return new RiakUserProvider($app->make('riak.connection'));
        });
    }
'guards' => [
    'web' => [
        'driver' => 'session',
        'provider' => 'users',
    ],
],
interface UserProvider
{
    public function retrieveById($identifier);
    public function retrieveByToken($identifier, $token);
    public function updateRememberToken(Authenticatable $user, $token);
    public function retrieveByCredentials(array $credentials);
    public function validateCredentials(Authenticatable $user, array $credentials);
}

Event
protected $listen = [
    'Illuminate\Auth\Events\Registered' => [
        'App\Listeners\LogRegisteredUser',
    ],
]

9/16
Authorization

Introduction
Gates
-Writing Gates
-Authorizing Actions
-Gate Responses
-Intercepting Gate Checks
Creating Policies
-Generating Policies
-Registering Policies
Writing Policies
-Policy Methods
-Policy Responses
-Methods Without Models
-Guest Users
-Policy Filters
Authorizing Actions Using Policies
-Via The User Model
-Via Middleware
-Via Controller Helpers
-Via Blade Templates
-Supplying Additional Context

Introduction
In addition to providing authentication services out of the box, Laravel also provides a simple way to authorize user actions against a given resource.

Writing Gates
public function boot()
{
    $this->registerPolicies();

    Gate::define('edit-settings', function ($user) {
        return $user->isAdmin;
    });

    Gate::define('update-post', function ($user, $post) {
        return $user->id === $post->user_id;
    });
}

public function boot()
{
    $this->registerPolicies();

    Gate::define('update-post', 'App\Policies\PostPolicy@update');
}
Authorizing Actions
To authorize an action using gates, you should use the allows or denies methods.
if (Gate::allows('edit-settings')) {
    // The current user can edit settings
}

if (Gate::allows('update-post', $post)) {
    // The current user can update the post...
}

if (Gate::denies('update-post', $post)) {
    // The current user can't update the post...
}
If you would like to determine if a particular user is authorized to perform an action, you may use the forUser method on the Gate facade:
if (Gate::forUser($user)->allows('update-post', $post)) {
}
if (Gate::forUser($user)->denies('update-post', $post)) {
}
You may authorize multiple actions at a time with the any or none methods:
if (Gate::any(['update-post', 'delete-post'], $post)) {
}
if (Gate::none(['update-post', 'delete-post'], $post)) {
}
Authorizing Or Throwing Exceptions
Gate::authorize('update-post', $post);
Supplying Additional Context
Gate::define('create-post', function ($user, $category, $extraFlag) {
    return $category->group > 3 && $extraFlag === true;
});

if (Gate::check('create-post', [$category, $extraFlag])) {
    // The user can create the post...
}

Gate Responses
use Illuminate\Auth\Access\Response;
use Illuminate\Support\Facades\Gate;

Gate::define('edit-settings', function ($user) {
    return $user->isAdmin
                ? Response::allow()
                : Response::deny('You must be a super administrator.');
});
$response = Gate::inspect('edit-settings', $post);

if ($response->allowed()) {
    // The action is authorized...
} else {
    echo $response->message();
}
Gate::authorize('edit-settings', $post);
Intercepting Gate Checks
Gate::before(function ($user, $ability) {
    if ($user->isSuperAdmin()) {
        return true;
    }
});
Gate::after(function ($user, $ability, $result, $arguments) {
    if ($user->isSuperAdmin()) {
        return true;
    }
});

Creating Policies
Generating Policies
php artisan make:policy PostPolicy
php artisan make:policy PostPolicy --model=Post
Registering Policies
 public function boot()
    {
        $this->registerPolicies();
    }
Writing Policies
Policy Methods
class PostPolicy
{
    public function update(User $user, Post $post)
    {
        return $user->id === $post->user_id;
    }
}
Policy Responses
public function update(User $user, Post $post)
{
    return $user->id === $post->user_id
                ? Response::allow()
                : Response::deny('You do not own this post.');
}
$response = Gate::inspect('update', $post);

if ($response->allowed()) {
    // The action is authorized...
} else {
    echo $response->message();
}
Gate::authorize('update', $post);
Methods Without Models
public function create(User $user)
{
    //
}
Guest Users
public function update(?User $user, Post $post)
    {
        return optional($user)->id === $post->user_id;
    }
Policy Filters
The before method will be executed before any other methods on the policy, giving you an opportunity to authorize the action before the intended policy method is actually called.
public function before($user, $ability)
{
    if ($user->isSuperAdmin()) {
        return true;
    }
}

Authorizing Actions Using Policies
Via The User Model
if ($user->can('update', $post)) {
    //
}
use App\Post;

if ($user->can('create', Post::class)) {
    // Executes the "create" method on the relevant policy...
}
Via Middleware
use App\Post;

Route::put('/post/{post}', function (Post $post) {
    // The current user may update the post...
})->middleware('can:update,post');
Route::post('/post', function () {
    // The current user may create posts...
})->middleware('can:create,App\Post');
public function update(Request $request, Post $post)
    {
        $this->authorize('update', $post);
    }
public function __construct()
    {
        $this->authorizeResource(Post::class, 'post');
    }
@can('update', $post)
    <!-- The Current User Can Update The Post -->
@elsecan('create', App\Post::class)
    <!-- The Current User Can Create New Post -->
@endcan

@cannot('update', $post)
    <!-- The Current User Cannot Update The Post -->
@elsecannot('create', App\Post::class)
    <!-- The Current User Cannot Create A New Post -->
@endcannot
These directives are convenient shortcuts for writing @if and @unless statements. The @can and @cannot statements above respectively translate to the following statements:

@if (Auth::user()->can('update', $post))
    <!-- The Current User Can Update The Post -->
@endif

@unless (Auth::user()->can('update', $post))
    <!-- The Current User Cannot Update The Post -->
@endunless
To accomplish this, use the @canany directive:

@canany(['update', 'view', 'delete'], $post)
    // The current user can update, view, or delete the post
@elsecanany(['create'], \App\Post::class)
    // The current user can create a post
@endcanany
@can('create', App\Post::class)
    <!-- The Current User Can Create Posts -->
@endcan

@cannot('create', App\Post::class)
    <!-- The Current User Can't Create Posts -->
@endcannot
Supplying Additional Context
public function update(User $user, Post $post, int $category)
{
    return $user->id === $post->user_id &&
           $category > 3;
}
public function update(Request $request, Post $post)
{
    $this->authorize('update', [$post, $request->input('category')]);
    // The current user can update the blog post...
}

9/20
Email Verification
Introduction
Model Preparation
Database Considerations
Routing
-Protecting Routes
Views
After Verifying Emails
Events

Introduction
Rather than forcing you to re-implement this on each application, Laravel provides convenient methods for sending and verifying email verification requests.

Model Preparation
To get started, verify that your App\User model implements the Illuminate\Contracts\Auth\MustVerifyEmail contract:
<?php

namespace App;

use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;

class User extends Authenticatable implements MustVerifyEmail
{
    use Notifiable;
}

Database Considerations
The Email Verification Column
php artisan migrate

Routing
Auth::routes(['verify' => true]);

Protecting Routes
Route::get('profile', function () {
    // Only verified users may enter...
})->middleware('verified');

Views
composer require laravel/ui

php artisan ui vue --auth

After Verifying Emails
protected $redirectTo = '/dashboard';

Events
Laravel dispatches events during the email verification process. You may attach listeners to these events in your EventServiceProvider:
protected $listen = [
    'Illuminate\Auth\Events\Verified' => [
        'App\Listeners\LogVerifiedUser',
    ],
];

9/21
Encryption

Introduction
Configuration
Using The Encrypter

Introduction
Laravel's encrypter uses OpenSSL to provide AES-256 and AES-128 encryption.

Configuration
Before using Laravel's encrypter, you must set a key option in your config/app.php configuration file.
php artisan key:generate

Using The Encrypter
-Encrypting A Value
 You may encrypt a value using the encryptString method of the Crypt facade. All encrypted values are encrypted using OpenSSL and the AES-256-CBC cipher.
 public function storeSecret(Request $request, $id)
    {
        $user = User::findOrFail($id);

        $user->fill([
            'secret' => Crypt::encryptString($request->secret),
        ])->save();
    }
Decrypting A Value
You may decrypt values using the decryptString method of the Crypt facade. 
try {
    $decrypted = Crypt::decryptString($encryptedValue);
} catch (DecryptException $e) {
    //
}

Hashing

Introduction
Configuration
Basic Usage

Introduction
The Laravel Hash facade provides secure Bcrypt and Argon2 hashing for storing user passwords.

Configuration
The default hashing driver for your application is configured in the config/hashing.php configuration file. 

Basic Usage
You may hash a password by calling the make method on the Hash facade:

public function update(Request $request)
    {
        $request->user()->fill([
            'password' => Hash::make($request->newPassword)
        ])->save();
    }

Adjusting The Bcrypt Work Factor
$hashed = Hash::make('password', [
    'rounds' => 12,
]);
Adjusting The Argon2 Work Factor
$hashed = Hash::make('password', [
    'memory' => 1024,
    'time' => 2,
    'threads' => 2,
]);
Verifying A Password Against A Hash
The check method allows you to verify that a given plain-text string corresponds to a given hash.
if (Hash::check('plain-text', $hashedPassword)) {
    // The passwords match...
}
Checking If A Password Needs To Be Rehashed
The needsRehash function allows you to determine if the work factor used by the hasher has changed since the password was hashed:

if (Hash::needsRehash($hashed)) {
    $hashed = Hash::make('plain-text');
}

Resetting Passwords

Introduction
Database Considerations
Routing
Views
After Resetting Passwords
Customization

Introduction
Rather than forcing you to re-implement this on each application, Laravel provides convenient methods for sending password reminders and performing password resets.

Database Considerations
Generating The Reset Token Table Migration
The migration for this table is included in the laravel/ui Composer package.
composer require laravel/ui
php artisan migrate

Routing
Laravel includes Auth\ForgotPasswordController and Auth\ResetPasswordController classes that contains the logic necessary to e-mail password reset links and reset user passwords. 
php artisan ui vue --auth

Views
To generate all of the necessary view for resetting passwords, you may use the laravel/ui Composer package:
composer require laravel/ui
php artisan ui vue --auth

After Resetting Passwords
Once you have defined the routes and views to reset your user's passwords, you may access the route in your browser at /password/reset. The ForgotPasswordController included with the framework already includes the logic to send the password reset link e-mails, while the ResetPasswordController includes the logic to reset user passwords.

After a password is reset, the user will automatically be logged into the application and redirected to /home. You can customize the post password reset redirect location by defining a redirectTo property on the ResetPasswordController:

protected $redirectTo = '/dashboard';

Customization
You can customize the included ResetPasswordController to use the guard of your choice by overriding the guard method on the controller. 
protected function guard()
{
    return Auth::guard('guard-name');
}
Password Broker Customization
In your auth.php configuration file, you may configure multiple password "brokers", which may be used to reset passwords on multiple user tables. You can customize the included ForgotPasswordController and ResetPasswordController to use the broker of your choice by overriding the broker method:
public function broker()
{
    return Password::broker('name');
}
Reset Email Customization
You may easily modify the notification class used to send the password reset link to the user. 
public function sendPasswordResetNotification($token)
{
    $this->notify(new ResetPasswordNotification($token));
}

9/22
Artisan Console

Introduction
-Tinker (REPL)
Writing Commands
-Generating Commands
-Command Structure
-Closure Commands
Defining Input Expectations
-Arguments
-Options
-Input Arrays
-Input Descriptions
Command I/O
-Retrieving Input
-Prompting For Input
-Writing Output
Registering Commands
Programmatically Executing Commands
-Calling Commands From Other Commands
Stub Customization

Introduction
Artisan is the command-line interface included with Laravel. 
php artisan list
php artisan help migrate

Tinker (REPL)
Laravel Tinker is a powerful REPL for the Laravel framework, powered by the PsySH package.
composer require laravel/tinker
php artisan tinker
php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"
Command Whitelist
Tinker utilizes a white-list to determine which Artisan commands are allowed to be run within its shell.
Classes That Should Not Be Aliased
'dont_alias' => [
    App\User::class,
],

Writing Commands
In addition to the commands provided with Artisan, you may also build your own custom commands. 
Generating Commands
php artisan make:command SendEmails
Command Structure
Let's take a look at an example command. 
class SendEmails extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'email:send {user}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Send drip e-mails to a user';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @param  \App\DripEmailer  $drip
     * @return mixed
     */
    public function handle(DripEmailer $drip)
    {
        $drip->send(User::find($this->argument('user')));
    }
}
Closure Commands
Closure based commands provide an alternative to defining console commands as classes.
protected function commands()
{
    require base_path('routes/console.php');
}
Artisan::command('build {project}', function ($project) {
    $this->info("Building {$project}!");
});
Type-Hinting Dependencies
Artisan::command('email:send {user}', function (DripEmailer $drip, $user) {
    $drip->send(User::find($user));
});
Closure Command Descriptions
This description will be displayed when you run the php artisan list or php artisan help commands:
Artisan::command('build {project}', function ($project) {
    $this->info("Building {$project}!");
})->describe('Build the project');

Defining Input Expectations
Arguments
All user supplied arguments and options are wrapped in curly braces.
protected $signature = 'email:send {user}';
You may also make arguments optional and define default values for arguments:
email:send {user?}
email:send {user=foo}
Options
protected $signature = 'email:send {user} {--queue}';
php artisan email:send 1 --queue
Options With Values
protected $signature = 'email:send {user} {--queue=}';
In this example, the user may pass a value for the option like so:
php artisan email:send 1 --queue=default
email:send {user} {--queue=default}
Option Shortcuts
email:send {user} {--Q|queue}
Input Arrays
email:send {user*}
php artisan email:send foo bar
email:send {user} {--id=*}
php artisan email:send --id=1 --id=2'

Input Descriptions
protected $signature = 'email:send
                        {user : The ID of the user}
                        {--queue= : Whether the job should be queued}';

Command I/O
Retrieving Input
public function handle()
{
    $userId = $this->argument('user');
}
If you need to retrieve all of the arguments as an array, call the arguments method:

$arguments = $this->arguments();
$queueName = $this->option('queue');
$options = $this->options();

Prompting For Input
public function handle()
{
    $name = $this->ask('What is your name?');
}
$password = $this->secret('What is the password?');
Asking For Confirmation
if ($this->confirm('Do you wish to continue?')) {
}
Auto-Completion
$name = $this->anticipate('What is your name?', ['Taylor', 'Dayle']);
$name = $this->anticipate('What is your name?', function ($input) {
    // Return auto-completion options...
});
Multiple Choice Questions
$name = $this->choice('What is your name?', ['Taylor', 'Dayle'], $defaultIndex);
$name = $this->choice(
    'What is your name?',
    ['Taylor', 'Dayle'],
    $defaultIndex,
    $maxAttempts = null,
    $allowMultipleSelections = false
);
Writing Output
public function handle()
{
    $this->info('Display this on the screen');
}
To display an error message, use the error method. Error message text is typically displayed in red:

$this->error('Something went wrong!');
$this->line('Display this on the screen');
Table Layouts
$headers = ['Name', 'Email'];
$users = App\User::all(['name', 'email'])->toArray();
$this->table($headers, $users);
Progress Bars
$users = App\User::all();

$bar = $this->output->createProgressBar(count($users));

$bar->start();

foreach ($users as $user) {
    $this->performTask($user);

    $bar->advance();
}

$bar->finish();
Registering Commands
protected function commands()
{
    $this->load(__DIR__.'/Commands');
    $this->load(__DIR__.'/MoreCommands');
}
protected $commands = [
    Commands\SendEmails::class
];
Artisan::queue('email:send', [
    'user' => 1, '--queue' => 'default'
])->onConnection('redis')->onQueue('commands');
Calling Commands From Other Commands
$this->call('email:send', [
        'user' => 1, '--queue' => 'default'
    ]);
$this->callSilent('email:send', [
    'user' => 1, '--queue' => 'default'
]);
To accomplish this, you may use the stub:publish command to publish the most common stubs for customization:
php artisan stub:publish

